// This file is part of https://github.com/KurtBoehm/grex.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#ifndef INCLUDE_GREX_BACKEND_X86_OPERATIONS_CLASSIFICATION_HPP
#define INCLUDE_GREX_BACKEND_X86_OPERATIONS_CLASSIFICATION_HPP

#include "grex/backend/defs.hpp"
#include "grex/backend/x86/helpers.hpp"
#include "grex/backend/x86/instruction-sets.hpp"
#include "grex/backend/x86/operations/abs.hpp" // IWYU pragma: keep
#include "grex/backend/x86/operations/compare.hpp" // IWYU pragma: keep
#include "grex/backend/x86/operations/set.hpp" // IWYU pragma: keep
#include "grex/backend/x86/types.hpp"
#include "grex/base/defs.hpp" // IWYU pragma: keep
#include <cstddef>

namespace grex::backend {
// based on VCL
#define GREX_ISFIN_AVX512_f32x4 __mmask8(_mm_fpclass_ps_mask(v.r, 0x99) ^ 0xFU)
#define GREX_ISFIN_AVX512_f32x8 __mmask8(~_mm256_fpclass_ps_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512_f32x16 __mmask16(~_mm512_fpclass_ps_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512_f64x2 __mmask8(_mm_fpclass_pd_mask(v.r, 0x99) ^ 0x3U)
#define GREX_ISFIN_AVX512_f64x4 __mmask8(_mm256_fpclass_pd_mask(v.r, 0x99) ^ 0xFU)
#define GREX_ISFIN_AVX512_f64x8 __mmask8(~_mm512_fpclass_pd_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512(KIND, BITS, SIZE, ...) \
  return {.r = GREX_ISFIN_AVX512_##KIND##BITS##x##SIZE};

#define GREX_ISFIN_INFTY_32 0x7F800000
#define GREX_ISFIN_INFTY_64 0x7FF0000000000000
// based on the assembly code generated by clang when using VCL,
// which is very far from VCLâ€™s implementation and more efficient than the more faithful
// assembly code which GCC generated
#define GREX_ISFIN_FALLBACK(KIND, BITS, SIZE, REGISTERBITS) \
  /* mask out the sign bit to simplify the following comparisons */ \
  const Vector<u##BITS, SIZE> vabs{GREX_KINDCAST(KIND, u, BITS, REGISTERBITS, abs(v).r)}; \
  /* broadcast positive infinity as an unsigned integer */ \
  const auto infty = broadcast(GREX_ISFIN_INFTY_##BITS, type_tag<Vector<u##BITS, SIZE>>); \
  /* if interpreted as an unsigned integer, positive infinity is the smalles non-finite value */ \
  return {.r = compare_lt(vabs, infty).r};

#if GREX_X86_64_LEVEL >= 4
#define GREX_ISFIN_IMPL GREX_ISFIN_AVX512
#else
#define GREX_ISFIN_IMPL GREX_ISFIN_FALLBACK
#endif

#define GREX_ISFIN(KIND, BITS, SIZE, ...) \
  inline Mask<KIND##BITS, SIZE> is_finite(Vector<KIND##BITS, SIZE> v) { \
    GREX_ISFIN_IMPL(KIND, BITS, SIZE, __VA_ARGS__) \
  }

#define GREX_ISFIN_ALL(REGISTERBITS, BITPREFIX) \
  GREX_FOREACH_FP_TYPE(GREX_ISFIN, REGISTERBITS, REGISTERBITS)
GREX_FOREACH_X86_64_LEVEL(GREX_ISFIN_ALL)

template<Vectorizable T, std::size_t tPart, std::size_t tSize>
inline SubMask<T, tPart, tSize> is_finite(SubVector<T, tPart, tSize> v) {
  return {.full = is_finite(v.full)};
}
template<typename THalf>
inline auto is_finite(SuperVector<THalf> v) {
  return SuperMask{.lower = is_finite(v.lower), .upper = is_finite(v.upper)};
}
} // namespace grex::backend

#endif // INCLUDE_GREX_BACKEND_X86_OPERATIONS_CLASSIFICATION_HPP
