// This file is part of https://github.com/KurtBoehm/grex.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#ifndef INCLUDE_GREX_BACKEND_X86_OPERATIONS_CLASSIFICATION_HPP
#define INCLUDE_GREX_BACKEND_X86_OPERATIONS_CLASSIFICATION_HPP

#include <cstddef>

#include <immintrin.h>

#include "grex/backend/base.hpp"
#include "grex/backend/macros/for-each.hpp"
#include "grex/backend/x86/instruction-sets.hpp"
#include "grex/backend/x86/macros/for-each.hpp"
#include "grex/backend/x86/macros/intrinsics.hpp"
#include "grex/backend/x86/operations/blend.hpp"
#include "grex/backend/x86/operations/expand-scalar.hpp"
#include "grex/backend/x86/operations/extract-single.hpp"
#include "grex/backend/x86/types.hpp"
#include "grex/base.hpp"

#if GREX_X86_64_LEVEL < 4
#include "grex/backend/x86/operations/abs.hpp"
#include "grex/backend/x86/operations/compare.hpp"
#include "grex/backend/x86/operations/set.hpp"
#endif

namespace grex::backend {
// based on VCL
#define GREX_ISFIN_AVX512_f32x4 _knot_mask8(_mm_fpclass_ps_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512_f32x8 _knot_mask8(_mm256_fpclass_ps_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512_f32x16 _knot_mask16(_mm512_fpclass_ps_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512_f64x2 _knot_mask8(_mm_fpclass_pd_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512_f64x4 _knot_mask8(_mm256_fpclass_pd_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512_f64x8 _knot_mask8(_mm512_fpclass_pd_mask(v.r, 0x99))
#define GREX_ISFIN_AVX512(KIND, BITS, SIZE, ...) \
  return {.r = GREX_ISFIN_AVX512_##KIND##BITS##x##SIZE};

#define GREX_ISFIN_INFTY_32 0x7F800000
#define GREX_ISFIN_INFTY_64 0x7FF0000000000000
// based on the assembly code generated by clang when using VCL,
// which is very far from VCLâ€™s implementation and more efficient than the more faithful
// assembly code which GCC generated
#define GREX_ISFIN_FALLBACK(KIND, BITS, SIZE, REGISTERBITS) \
  /* mask out the sign bit to simplify the following comparisons */ \
  const Vector<i##BITS, SIZE> vabs{GREX_KINDCAST(KIND, i, BITS, REGISTERBITS, abs(v).r)}; \
  /* broadcast positive infinity as an unsigned integer */ \
  const auto infty = broadcast(GREX_ISFIN_INFTY_##BITS, type_tag<Vector<i##BITS, SIZE>>); \
  /* if interpreted as an unsigned integer, positive infinity is the smallest non-finite value */ \
  return {.r = compare_lt(vabs, infty).r};

#if GREX_X86_64_LEVEL >= 4
#define GREX_ISFIN_IMPL GREX_ISFIN_AVX512
#else
#define GREX_ISFIN_IMPL GREX_ISFIN_FALLBACK
#endif

#define GREX_ISFIN(KIND, BITS, SIZE, ...) \
  inline Mask<KIND##BITS, SIZE> is_finite(Vector<KIND##BITS, SIZE> v) { \
    GREX_ISFIN_IMPL(KIND, BITS, SIZE, __VA_ARGS__) \
  }

#define GREX_ISFIN_ALL(REGISTERBITS, BITPREFIX) \
  GREX_FOREACH_FP_TYPE(GREX_ISFIN, REGISTERBITS, REGISTERBITS)
GREX_FOREACH_X86_64_LEVEL(GREX_ISFIN_ALL)

template<FloatVectorizable T, std::size_t tPart, std::size_t tSize>
inline SubMask<T, tPart, tSize> is_finite(SubVector<T, tPart, tSize> v) {
  return SubMask<T, tPart, tSize>{is_finite(v.full)};
}
template<typename THalf>
inline auto is_finite(SuperVector<THalf> v) {
  return SuperMask{.lower = is_finite(v.lower), .upper = is_finite(v.upper)};
}

template<AnyVector TVec>
inline TVec make_finite(TVec v) {
  return blend_zero(is_finite(v), v);
}
template<FloatVectorizable T>
inline Scalar<T> make_finite(Scalar<T> v) {
  const auto vec = expand_any(v, index_tag<16 / sizeof(T)>);
  return extract_single(blend_zero(is_finite(vec), vec));
}
} // namespace grex::backend

#endif // INCLUDE_GREX_BACKEND_X86_OPERATIONS_CLASSIFICATION_HPP
